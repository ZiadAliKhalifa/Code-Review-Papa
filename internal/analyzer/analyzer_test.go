package analyzer

import (
	"context"
	"fmt"
	"strings"
	"testing"

	"github.com/ziadalikhalifa/code-review-papa/internal/mocks"
)

const (
	defaultHeader = `# üßô‚Äç‚ôÇÔ∏è Code Review Papa

I've analyzed this pull request and have some feedback for you!

`
	defaultFooter = `

---
*This automated review was generated by [Code Review Papa](https://github.com/ziadalikhalifa/code-review-papa). If you find this helpful, please give it a ‚≠ê!*
`
)

func TestFormatComment(t *testing.T) {
	testCases := []struct {
		name           string
		input          string
		expectedOutput string
	}{
		{
			name:           "EmptyAnalysis",
			input:          "",
			expectedOutput: defaultHeader + "" + defaultFooter,
		},
		{
			name:           "AnalysisWithCodeReviewLowerCase",
			input:          "This is a code review.",
			expectedOutput: "This is a code review." + defaultFooter,
		},
		{
			name:           "AnalysisWithCodeReviewUpperCase",
			input:          "This is a CODE REVIEW.",
			expectedOutput: "This is a CODE REVIEW." + defaultFooter,
		},
		{
			name:           "AnalysisWithCodeReviewMixedCase",
			input:          "This is a CoDe ReViEw.",
			expectedOutput: "This is a CoDe ReViEw." + defaultFooter,
		},
		{
			name:           "AnalysisWithoutCodeReview",
			input:          "This is a test analysis.",
			expectedOutput: defaultHeader + "This is a test analysis." + defaultFooter,
		},
		{
			name:           "AnalysisWithDeepSeekHeader",
			input:          "Code Review Papa says: Hello!",
			expectedOutput: "Code Review Papa says: Hello!" + defaultFooter,
		},
		{
			name:           "AnalysisWithDeepSeekHeaderAndMoreText",
			input:          "Code Review Papa\n\nHere is your review.",
			expectedOutput: "Code Review Papa\n\nHere is your review." + defaultFooter,
		},
		{
			name:           "AnalysisWithLowerCaseCodeReviewPapa",
			input:          "code review papa analyzed this.",
			expectedOutput: "code review papa analyzed this." + defaultFooter,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			actualOutput := formatComment(tc.input)
			if actualOutput != tc.expectedOutput {
				t.Errorf("formatComment(%q) = %q; want %q", tc.input, actualOutput, tc.expectedOutput)
			}
		})
	}
}

func TestAnalyzePR(t *testing.T) {
	owner := "testowner"
	repo := "testrepo"
	prNumber := 1

	actualDiffTooLargeComment := "‚ö†Ô∏è **Code Review Papa**: This PR is too large for automated review. Consider breaking it into smaller PRs for better feedback."

	tests := []struct {
		name                 string
		setupMock            func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T)
		expectedErr          bool
		expectedComment      *string
		expectCommentNotCalled bool
	}{
		{
			name: "PRAlreadyCommented",
			setupMock: func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T) {
				mockGH.HasExistingCommentsFunc = func(ctx context.Context, o, r string, num int) (bool, error) {
					if o != owner || r != repo || num != prNumber {
						t.Errorf("HasExistingComments called with unexpected args: owner %s, repo %s, number %d", o, r, num)
					}
					return true, nil
				}
			},
			expectedErr: false,
			expectCommentNotCalled: true,
		},
		{
			name: "GetDiffError",
			setupMock: func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T) {
				mockGH.HasExistingCommentsFunc = func(ctx context.Context, o, r string, num int) (bool, error) { return false, nil }
				mockGH.GetPullRequestDiffFunc = func(ctx context.Context, o, r string, num int) (string, error) {
					if o != owner || r != repo || num != prNumber {
						t.Errorf("GetPullRequestDiff called with unexpected args: owner %s, repo %s, number %d", o, r, num)
					}
					return "", fmt.Errorf("diff error")
				}
			},
			expectedErr: true,
			expectCommentNotCalled: true,
		},
		{
			name: "EmptyDiff",
			setupMock: func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T) {
				mockGH.HasExistingCommentsFunc = func(ctx context.Context, o, r string, num int) (bool, error) { return false, nil }
				mockGH.GetPullRequestDiffFunc = func(ctx context.Context, o, r string, num int) (string, error) { return "", nil }
			},
			expectedErr: false,
			expectCommentNotCalled: true,
		},
		{
			name: "DiffTooLarge",
			setupMock: func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T) {
				mockGH.HasExistingCommentsFunc = func(ctx context.Context, o, r string, num int) (bool, error) { return false, nil }
				mockGH.GetPullRequestDiffFunc = func(ctx context.Context, o, r string, num int) (string, error) {
					return strings.Repeat("a", 100001), nil
				}
				mockGH.CommentOnPullRequestFunc = func(ctx context.Context, o, r string, num int, comment string) error {
					if o != owner || r != repo || num != prNumber {
						t.Errorf("CommentOnPullRequest called with unexpected args: owner %s, repo %s, number %d", o, r, num)
					}
					if comment != actualDiffTooLargeComment {
						t.Errorf("CommentOnPullRequest called with unexpected comment: got %q, want %q", comment, actualDiffTooLargeComment)
					}
					return nil
				}
			},
			expectedErr:     false,
			expectedComment: &actualDiffTooLargeComment,
		},
		{
			name: "AIServiceError",
			setupMock: func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T) {
				mockGH.HasExistingCommentsFunc = func(ctx context.Context, o, r string, num int) (bool, error) { return false, nil }
				mockGH.GetPullRequestDiffFunc = func(ctx context.Context, o, r string, num int) (string, error) { return "valid diff", nil }
				mockAI.AnalyzeCodeFunc = func(ctx context.Context, diff string) (string, error) {
					if diff != "valid diff" {
						t.Errorf("AnalyzeCode called with unexpected diff: %s", diff)
					}
					return "", fmt.Errorf("ai error")
				}
			},
			expectedErr: true,
			expectCommentNotCalled: true,
		},
		{
			name: "CommentOnError",
			setupMock: func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T) {
				mockGH.HasExistingCommentsFunc = func(ctx context.Context, o, r string, num int) (bool, error) { return false, nil }
				mockGH.GetPullRequestDiffFunc = func(ctx context.Context, o, r string, num int) (string, error) { return "valid diff", nil }
				mockAI.AnalyzeCodeFunc = func(ctx context.Context, diff string) (string, error) { return "valid analysis", nil }
				mockGH.CommentOnPullRequestFunc = func(ctx context.Context, o, r string, num int, comment string) error {
					expectedC := formatComment("valid analysis")
					if comment != expectedC {
						t.Errorf("CommentOnPullRequest called with unexpected comment: got %q, want %q", comment, expectedC)
					}
					return fmt.Errorf("comment error")
				}
			},
			expectedErr: true,
			expectedComment: func() *string { s := formatComment("valid analysis"); return &s }(),
		},
		{
			name: "SuccessfulAnalysis",
			setupMock: func(mockGH *mocks.MockGithubClient, mockAI *mocks.MockAIService, t *testing.T) {
				mockGH.HasExistingCommentsFunc = func(ctx context.Context, o, r string, num int) (bool, error) { return false, nil }
				mockGH.GetPullRequestDiffFunc = func(ctx context.Context, o, r string, num int) (string, error) { return "valid diff", nil }
				mockAI.AnalyzeCodeFunc = func(ctx context.Context, diff string) (string, error) { return "valid analysis", nil }
				mockGH.CommentOnPullRequestFunc = func(ctx context.Context, o, r string, num int, comment string) error {
					expectedC := formatComment("valid analysis")
					if o != owner || r != repo || num != prNumber {
						t.Errorf("CommentOnPullRequest called with unexpected args: owner %s, repo %s, number %d", o, r, num)
					}
					if comment != expectedC {
						t.Errorf("CommentOnPullRequest called with unexpected comment: got %q, want %q", comment, expectedC)
					}
					return nil
				}
			},
			expectedErr: false,
			expectedComment: func() *string { s := formatComment("valid analysis"); return &s }(),
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			mockGH := &mocks.MockGithubClient{}
			mockAI := &mocks.MockAIService{}
			commentPosted := false
			
			// Store original CommentOnPullRequestFunc to wrap it for tracking
			var originalCommentFunc func(ctx context.Context, owner, repo string, number int, comment string) error

			if tc.setupMock != nil {
				tc.setupMock(mockGH, mockAI, t)
			}

			// Wrap CommentOnPullRequestFunc to track if it was called, only if it's set by setupMock
			if mockGH.CommentOnPullRequestFunc != nil {
				originalCommentFunc = mockGH.CommentOnPullRequestFunc
				mockGH.CommentOnPullRequestFunc = func(ctx context.Context, owner, repo string, number int, comment string) error {
					commentPosted = true
					return originalCommentFunc(ctx, owner, repo, number, comment)
				}
			}


			analyzer := NewPRAnalyzer(mockGH, mockAI)
			err := analyzer.AnalyzePR(context.Background(), owner, repo, prNumber)

			if tc.expectedErr && err == nil {
				t.Errorf("expected an error, but got nil")
			}
			if !tc.expectedErr && err != nil {
				t.Errorf("did not expect an error, but got: %v", err)
			}

			if tc.expectedComment != nil {
				if !commentPosted {
					t.Errorf("CommentOnPullRequestFunc was expected to be called, but it wasn't")
				}
				// The actual comment content check is now part of the mock function itself
			} else if tc.expectCommentNotCalled {
                 if commentPosted {
                    t.Errorf("CommentOnPullRequestFunc was not expected to be called, but it was")
                }
            }


			// Specific checks for function calls
			if tc.name == "PRAlreadyCommented" {
				if mockGH.GetPullRequestDiffFunc != nil {
					t.Errorf("GetPullRequestDiffFunc should not have been called for PRAlreadyCommented")
				}
				if mockAI.AnalyzeCodeFunc != nil {
					t.Errorf("AnalyzeCodeFunc should not have been called for PRAlreadyCommented")
				}
			}

			if tc.name == "EmptyDiff" {
				if mockAI.AnalyzeCodeFunc != nil {
                     t.Errorf("AnalyzeCodeFunc should not have been called for EmptyDiff")
                }
			}
		})
	}
}
